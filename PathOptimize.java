/**
 * $Id$
 * 
 * Optimize path and location data generated by the ShowImage editor by
 * flattening mulitple overlapping nodes, adding nodes at intersections,
 * and compressing path vectors into a graph structure. 
 */

import java.awt.*;
import java.io.*;
import java.util.*;

public class PathOptimize
{
	// These fields only hold data from readData
    private Vector readPaths; // Vector of paths
    private Vector readLocations;  // Vector of locations (see class Locations)

    private Vector pathPoints;
    
    private Vector graphPoints;
    
    // These fields are for the vectors to be written out in a format
    // that can be read by ShowImage
    private Vector outPaths;
    private Vector outLocations;
    private Vector outEdges = new Vector();

    /** Driver */
    public static void main(String[] args)
    {
    	
    	final String rawPathFile = "data/rawPath.dat";
    	final String rawLocFile = "data/rawLocations.dat";
    	final String optPathFile = "data/optimizedPath.dat";
    	final String optLocFile = "data/optimizedLocations.dat";
    	final String binaryPoints = "data/binPointData.dat";
    	final String binaryLocations =  "data/binLocationData.dat";
    	final String binaryEdges = "data/binEdgeData.dat";
    	run(rawPathFile, rawLocFile, optPathFile, optLocFile,
    			binaryPoints, binaryLocations, binaryEdges
    	);
    }
    
    /**
     * Runs the optimization program.  
     * @param inPathFile Incomming path file
     * @param inLocFile Incoming locations file
     * @param outPathFile Outgoing path file
     * @param outLocFile Outgoing locations file
     * @return boolean is success.  
     */
    public static boolean run(String inPathFile, String inLocFile,
    		String outPathFile, String outLocFile, 
			String binaryPoints, String binaryLocations, String binaryEdges)
    {
    	PathOptimize pathOp = new PathOptimize();
    	
        // we abort immediately if we can't load our input files
    	//   
    	
    	/*
    	 * This reads in the Vector of vector of points and Vector of 
    	 * locations.  These go into the field readPoints and readLocation.
    	 */
    	if(! pathOp.readPoints(inPathFile, inLocFile) )
            return(false);
    	
        
    	/*
    	 * Convert the incoming paths of points that we read in
    	 * They come in as Vectors of a Vectors of Points
    	 * That is, it's a Vector where each element of the vector
    	 * contains a Vector which contains points
    	 * Takes the points from readLocations and readPoints.  
    	 */
    	pathOp.convertPointsToPathPoints();
    	/*
    	 * Data is now all stored in the pathPoints vector
    	 */
    	
    	
    	//Collapse all duplications of PathPoints.  
    	pathOp.condensePathPoints();
    	
    	/* 
    	 * Create new pathPoints at intersections and redirect "links" of 
    	 * the points that caused the intersections to the intersection
    	 * point
    	 */
    	pathOp.intersections();
    	
    	/*
    	 * 
    	 */
    	pathOp.convertPathPointsToGraphPoints();
    	pathOp.convertGraphPointsToPoints();
    	pathOp.writePoints(outPathFile, outLocFile);
    	pathOp.binaryWrite(binaryPoints, binaryLocations, binaryEdges);
    	return(true);
    }
    
    /**
     * Generic constructor. It just initializes all the member fields.
     */
    public PathOptimize()
    {
    	outLocations = new Vector();
    	outPaths = new Vector();
    	pathPoints = new Vector();
    	readLocations = new Vector();
    	readPaths = new Vector();
    }
    
    /**
     * Method readData,  loads the paths and locations fields from 
     * files.  
     */
    public boolean readPoints(String pathFileName, String locFileName){
        boolean pathLoadSuccess = false;
        boolean locationLoadSuccess = false;
		// Load files
		final String pathNotFound = 
			"File \"" + pathFileName + "\" not found!     ";
		final String locNotFound = "File \"" + locFileName + "\" not found!";
		// Define input files for paths and locations.
	    File pathsInputFile = new File(pathFileName);
	    File locationsInputFile = new File(locFileName);
	    
	    // Get the paths vector
	    try{
	    	// Open stream
	        ObjectInputStream pathin = new ObjectInputStream(
	                new FileInputStream(pathsInputFile));
	        // Get Vector
	        readPaths = (Vector)pathin.readObject();
	        // close stream
	        pathin.close();
            pathLoadSuccess = true;
	    }
	    catch(FileNotFoundException e){
	    	System.err.println(pathNotFound);
	    }
	    catch(Exception e){
	    	System.err.println("Error in opening \"" + pathFileName + "\"!");
	    }
	    
	    // Get the locations vector
	    try{
	        // Open stream
	        ObjectInputStream locin = new ObjectInputStream(
	                new FileInputStream(locationsInputFile));
	        // Get Vector
	        readLocations = (Vector)locin.readObject();
	        //close stream
	        locin.close();
            locationLoadSuccess = true;
	    }
	    catch(FileNotFoundException e){
	    	System.err.println(locNotFound);
	    }
	    catch(Exception e){
	    	System.err.println("Error in opening \"" + locFileName + "\"!");
	    }
        
        return( pathLoadSuccess && locationLoadSuccess );
	}
    
    
    /**
	 * Convert the points and locations (from a ShowImage data file) to
	 * PathPoints.
	 * Step through all paths, and for each path, create PathPoints as you
	 * go along, all of them linked together.  
	 */
    public void convertPointsToPathPoints()
    {
    	
    	Point inPoint;  // This is the current point in the "path"
    					// that we are working with
    	
    	Location atlocation;  // The location at the "current point"
    	
    	PathPoint currentPP;  // The current Path Point we are at
    	PathPoint prevPP;  // The previous Path Point we were at
    	
    	//For each vector of points in the vector of "paths"
    	// Each path is a set of points
    	for(int pathIndex = 0; pathIndex < readPaths.size(); pathIndex++)
    	{
    		// We have no previous point initially, so set it to null.
    		prevPP = null;
    		
    		// For every point in the "path"
    		for(int elementIndex = 0;
    		elementIndex < ( (Vector)( readPaths.get(pathIndex) )).size(); 
    		elementIndex++)
    		{
    			// Return the current point that we are at
    			inPoint = pointInReadPaths(pathIndex, elementIndex);
    			
    			// Return the location at the point (method only returns a
    			// location if it exists).  So, if no location exists,
    			// atLocation is null.
    			atlocation = locationAtPoint(inPoint);
    			
    			// initialize the current PathPoint
    			// this is a constructor call.
    			currentPP = new PathPoint(inPoint, new Vector(2), atlocation);
    			// Add the newPathPoint to the vector of Path Points
    			pathPoints.add(currentPP);
    			
    			// As long as there is a previous point, 
    			// cross nit the two together.  
    			if(prevPP != null){
    				currentPP.addConnectedPoint(prevPP);
    				prevPP.addConnectedPoint(currentPP);
    			}
    			// The current current will become previous when the current
    			// current is no longer current.  :)
    			prevPP = currentPP;
    		}

    	}
    }
    
    public void convertGraphPointsToPoints()
    {
    	for(int graphIndex = 0; graphIndex < graphPoints.size(); graphIndex++)
    	{
    		// Get the GraphPoint
    		GraphPoint thisGP = (GraphPoint)graphPoints.get(graphIndex);
    		// Handle locations
    		if(thisGP.locLabel != null)
    		{
	    		System.err.println("Adding location: " + thisGP.locLabel.cord +
	    				", " + thisGP.locLabel.name);
	    		outLocations.add( thisGP.locLabel );
    		}
    	}
    }
    
    /**
     * OBSOLETE
     * Convert a set of PathPoints to a (highly unoptimized) set of paths
     * that can be read by ShowImage.
     *
     */
    public void convertPathPointsToPoints()
    {
        // loop through all PathPoints
    	for(int pathIndex = 0; pathIndex < pathPoints.size(); pathIndex++)
    	{
    		PathPoint thisPoint = (PathPoint)pathPoints.get(pathIndex);
    		
    		// if this PathPoint is associated with a location, add it to
    		// the outgoing Locations vector
    		if(thisPoint.location != null)
    		{
	    		System.err.println("Adding location: " + thisPoint.location.cord +
	    				", " + thisPoint.location.name);
	    		outLocations.add( thisPoint.location );
    		}
    		
    		// if this PathPoint has no connections, just add it as a single
    		// one-point path, and move on.
    		if(thisPoint.numConnectedPoints() == 0)
    		{
    			Vector thisPath = new Vector(2);
    			thisPath.add( thisPoint.point );
    			outPaths.add(thisPath);
    			continue;
    		}
    		
    		// otherwise, loop through each of this PathPoint's connections
    		for(int conPoint = 0; conPoint < thisPoint.numConnectedPoints();
    				conPoint++)
    		{
    			// create a new vector to represent this path
    			// (which consists of only two points)
    			Vector thisPath = new Vector(2);
    			thisPath.add( thisPoint.point );
    			thisPath.add( thisPoint.getConnectedPoint(conPoint) );
    			
    			// add the new vector to the list of paths
    			outPaths.add(thisPath);
    		}
    	}
    }
    
    /**
     * Write ShowImage-style data to disk.
     */
    public void writePoints(String pathFileName, String locFileName){
        boolean pathWriteSuccess = false;
    	boolean locationWriteSuccess = false;
		// Load files
		final String pathNotFound = 
			"File \"" + pathFileName + "\" not found!     ";
		final String locNotFound = "File \"" + locFileName + "\" not found!";
    	// Define output files for paths and locations.
        File pathOutputFile = new File(pathFileName);
        File locationOutputFile = new File(locFileName);
        try{
        	// Write out the paths vector
            ObjectOutputStream pathout = new ObjectOutputStream(
                    new FileOutputStream(pathOutputFile));
            pathout.writeObject(outPaths);
            pathWriteSuccess = true;
            // close stream
            pathout.close();
        }
	    catch(FileNotFoundException e){
	    	System.err.println(pathNotFound);
	    }
	    catch(IOException e){
	    	
	    	System.err.println("Error in writing \"" + pathFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    }
	    
        try{
            // Write out the locations vector
            ObjectOutputStream locout = new ObjectOutputStream(
                    new FileOutputStream(locationOutputFile));
            locout.writeObject(outLocations);
            locationWriteSuccess = true;
            //close stream
            locout.close();
        }
	    catch(FileNotFoundException e){
	    	System.err.println(locNotFound);
	    }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + locFileName + "\"!");
	    }
	    if(locationWriteSuccess && pathWriteSuccess){
	        // Set status
        }
    }
    
    /**
     * Write data to disk in binary format, suitable for reading from
     * the web-based frontend.
     */
    public void binaryWrite(String pointFileName, String locFileName,
    		String edgeFileName){
		
		File pointOutputFile = new File(pointFileName);
        File locOutputFile = new File(locFileName);
        File edgeOutputFile = new File(edgeFileName);
        
        // output point data
        try{
            DataOutputStream pointOut= new DataOutputStream(
                    new FileOutputStream(pointOutputFile));
            
            System.err.println("===== GraphPoints =====");
            // for each GraphPoint
            for(int i = 0; i < graphPoints.size(); i++)
            {
            	((GraphPoint)graphPoints.get(i)).binaryWrite(pointOut);
            }
            
            //close stream
            pointOut.close();
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + pointFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
	    
	    // output location data
        try{
            DataOutputStream locOut= new DataOutputStream(
                    new FileOutputStream(locOutputFile));
            
            System.err.println("===== Locations =====");
            // for each Location
            for(int i = 0; i < graphPoints.size(); i++)
            {
            	// if this point has no associated location, nothing is written
            	((GraphPoint)graphPoints.get(i)).binaryWriteLocation(locOut);
            }
            //close stream
            locOut.close();
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + locFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
	    
	    // output edge data
        try{
            DataOutputStream edgeOut= new DataOutputStream(
                    new FileOutputStream(edgeOutputFile));
            
            System.err.println("===== Edges =====");
            // for each Edge
            for(int i = 0; i < outEdges.size(); i++)
            {
            	((Edge)outEdges.get(i)).binaryWrite(edgeOut);
            }
            //close stream
            edgeOut.close();
        }
	    catch(IOException e){
	    	System.err.println("Error in writing \"" + edgeFileName + "\"!\n"
	    			+ e + ": " + e.getMessage());
	    	return;
	    }
    }
	
    /**
     * Return a Location (from readLocations) that corresponds with the given
     * Point (from readPaths).
     * @param pointToCompare Point to compare for locations
     * @return the Location associated with pointToCompare, or null if none
     * is found.
     */
    public Location locationAtPoint(Point pointToCompare)
    {
    	for(int locIndex = 0; locIndex < readLocations.size(); locIndex++){
			if ((getReadLocation(locIndex).cord).equals(pointToCompare))
			{
				return(getReadLocation(locIndex));
			}
    	}
    	return(null);
    }
    
    /**
     * Get the location at the given index in the readLocations Vector.
     * @param locIndex Index of Location to return
     * @return the Location at locIndex
     */
    public Location getReadLocation(int locIndex){
    	return((Location)readLocations.get(locIndex));
    }
    
    /**
     * Return a Point in a "path" in the vector of "paths".
     * The "path" to choose from the Vector of paths is specified by pathIndex.
     * The point in the "path" to grap is specified by elementIndex.
     * 
     * @param pathIndex The index determining the path to choose.
     * @param elementIndex The index determining the element in the path.
     * @return point at a given path index in a given path.  
     */
    public Point pointInReadPaths(int pathIndex, int elementIndex)
    {
    	return((Point)((Vector)readPaths.get(pathIndex)).get(elementIndex));    	
    }
    
    /**
     * Condense all overlapping PathPoints into single PathPoints with
     * appropriate links.
     */
    public void condensePathPoints ()
    {
		// active PathPoint (the one who we will use to check for overlaps)
    	PathPoint active;
    	
		// Set overlap PathPoint (the one that is a candidate for removal)
    	PathPoint overlap;
    	
    	//a PathPoint that is connected to the overlap PathPoint
    	PathPoint overlapConnection;
    	
    	// Loop through all PathPoints in Paths Vector
    	for(int activeIndex = 0; activeIndex<pathPoints.size(); activeIndex++){
    		// Set active PathPoint (the one to check for overlaps)
    		active = getPathPoint(activeIndex);
    		
    		// Loop through all path points again to look for intersections
    		for(int overlapIndex = 0; overlapIndex < pathPoints.size();
    			overlapIndex++)
    		{
    			// Skip the active PathPoint (because's it's identical to
    			// itself.
    			if(activeIndex == overlapIndex)
    				continue;
    			
    			// If the active PathPoint intersects with a PathPoint, 
    			// then that PathPoint is an overlap PathPoint
    			if(getPointAtPathPointsIndex(activeIndex).equals(
    					getPointAtPathPointsIndex(overlapIndex)))
    			{
    				// Set overlap PathPoint (the one that is going to be
    				// removed
    				overlap = getPathPoint(overlapIndex);
    				// For all points that are connected to that overlap 
    				// PathPoint
    				// ... link the connected pathPoints to the active 
    				// PathPoint
    				for(int conPointIndex = 0; 
    						conPointIndex < overlap.numConnectedPoints();
    						conPointIndex++)
    				{
    					// Set the PathPoint that is connected to the 
    					// overlap PathPoint
    					overlapConnection = 
    						overlap.getConnectedPathPoint(conPointIndex);
    					
    					// Remove the overlap PathPoint from the PathPoint
    					// that is/was connected to the overlap PathPoint
    					overlapConnection.removeConnectedPoint(overlap);
    					
    					// Add the active (the PathPoint we are overwriting
    					// over the overlap PathPoint) to the PathPoint
    					// that was connected to the overlap PathPoint.
    					overlapConnection.addConnectedPoint(active);
    					
    					// Add the connected PathPoint to the active
    					// PathPoint
    					active.addConnectedPoint(overlapConnection);
    				}
    				
    				// Remove the overlapping PathPoint
    				pathPoints.remove(overlap);
    			}
    		}
    	}
    }
    
    /**
     * Find all intersections of connections from PathPoints, and add new,
     * connected PathPoints at these spots.
     */
    public void intersections ()
    {
    	PathPoint ap1;  // Active point 1
    	PathPoint ap2;  // Active point 2
    	PathPoint tp1;  // Test point 1
    	PathPoint tp2;  // Test point 2
    	
    	// The intersect coordinates
    	double intersectX;
    	double intersectYTest;
    	double intersectYActive;
    	double activeSlope;
    	double testSlope;
    	
    	boolean intersect = false;  // For vertical test
    	
    	int ovIndex;
    	
    	// Loop through all PathPoints in Paths Vector
    	for(int activeIndex1 = 0; activeIndex1<pathPoints.size(); 
    	activeIndex1++)
    	{
    		// store the first point in our active line segment
    		ap1 = getPathPoint(activeIndex1);
    		
			// For all points that are connected to that active point 1 
			// PathPoint
    		
			// now loop through all the points, again
			for(int testIndex1 = 0; testIndex1<pathPoints.size(); 
	    		testIndex1++)
	    	{
			    // store the first point in the test line segment
	    		tp1 = getPathPoint(testIndex1);
	    		//If the test point and active point are the same
	    		// Get a new test point.  
	    		if(tp1.equals(ap1))
	    			continue;
    		
AP1:    		for(int activeIndex2 = 0; 
					activeIndex2 < ap1.numConnectedPoints();
					activeIndex2++)
				{
	
					// the second point in the active line segment
					ap2 = ap1.getConnectedPathPoint(activeIndex2);
					// if the test point as  the second active point,
					// skip it.  If the 2nd active point is the same
					// as the first, skip it.  
					if(tp1.equals(ap2) || ap1.equals(ap2))
						continue;
					
					// test if this line (ap1-ap2) represents a bridge, tunnel,
					// etc.
					if(!ap1.allowLink(ap2))
						continue;
                    
					activeSlope = getSlope(ap1, ap2);
		    		

		    		
					// For all points that are connected to that test point 1 
					// PathPoint
					for(int testIndex2 = 0; 
						testIndex2 < tp1.numConnectedPoints();
						testIndex2++)
					{
					    // store the second point in the test line segment
						tp2 = tp1.getConnectedPathPoint(testIndex2);
						
						// if _this_ point is one of the active points, skip it
						// if _this_ point is the same as the first test point
						// skip!
			    		if(tp2.equals(ap1) || tp2.equals(ap2) 
			    				|| tp2.equals(tp1))
			    			continue;
						
			    		
			    		// test if this line (tp1-tp2) represents a bridge, tunnel,
						// etc.
						if(!tp1.allowLink(tp2))
							continue;
						
			    		// this is The Rectangle Test
			    		if(!rectangleTest(ap1, ap2, tp1, tp2))
			    			continue;
			    		
						System.err.print(
								"ap1: (" + ap1.point.x + ", " + ap1.point.y + ") ");
						
						System.err.println(
								";  ap2: (" + ap2.point.x + ", " + ap2.point.y + ") ");
						
						System.err.print(
								"tp1: (" + tp1.point.x + ", " + tp1.point.y + ") ");
						
						System.err.println(
								";  tp2: (" + tp2.point.x + ", " + tp2.point.y + ") ");
						
						System.err.println("Active slope: " + activeSlope);
			    		
						testSlope = getSlope(tp1, tp2);

						System.err.println("Test slope: " + testSlope);
						
						if(testSlope == activeSlope)
							continue;

						// calculate the possible X intersect coordinate
						intersectX =
							((  (activeSlope*(ap1.point.x) - ap1.point.y)
								- (testSlope*(tp1.point.x) - tp1.point.y))/
							   (activeSlope - testSlope));
						
						// calculate the two possible Y intersect coordinates
						intersectYTest = ((testSlope)
						        * (intersectX - tp1.point.x) + tp1.point.y);
						intersectYActive = ((activeSlope)
						        * (intersectX - ap1.point.x) + ap1.point.y);
						
						// if the two Y intersect coordinates are the same,
						// it's a real intersection
						
						// If vertical line!
						if(Double.isInfinite(activeSlope) && 
								Double.isInfinite(testSlope))
							continue;
						intersect = false;
						if(Double.isInfinite(activeSlope) && 
								!Double.isInfinite(testSlope))
						{
							intersectYTest = ((testSlope)
									*(ap1.point.x-tp1.point.x) + tp1.point.y);
							intersect = 
								checkRange(ap1.point.y, 
										ap2.point.y, intersectYTest);
							intersectX = ap1.point.x;
						}
						if(Double.isInfinite(testSlope) && 
								!Double.isInfinite(activeSlope))
						{
							intersectYActive = ((activeSlope)
							        * (tp1.point.x - ap1.point.x) + ap1.point.y);
							intersect = 
								checkRange(tp1.point.y, 
										tp2.point.y, intersectYActive);
							intersectX = tp1.point.x;
						}
						System.err.println("iA: " + intersectYActive + "\n" +
								"iT: " + intersectYTest);
						if((Math.abs(intersectYActive-intersectYTest) < 0.00001)
								|| intersect)
						{
							System.err.println("Points are equal!");
							System.err.println("(" + intersectX + ", " 
									+ intersectYTest + ")");
							
							// (this is actually supposed to be "P-sub-i", not
                            // the Greek letter Pi.)
							// create a PathPoint in the location of the
							// potential intercept point
							PathPoint pi = new PathPoint(
							        new Point( (int)intersectX,
							                (int)intersectYTest),
							        new Vector(2), null );
							
							System.err.println(
									"pi: (" + pi.point.x + ", " + pi.point.y + ") ");
							
							// ensure that the potential point is actually on
							// both lines
							if(!pointInSegments(ap1, ap2, tp1, tp2, pi))
								continue;
							
							// congratulations, you've found an intercept!
							
							if ((ovIndex = checkForPathPointOverlap(pi)) != -1)
							{
								pi = (PathPoint)pathPoints.get(ovIndex);
								// and integrate the new point with its neighbors
								if(!pi.equals(ap1) && !pi.equals(ap2))
									twoWayIntersectReplace(ap1, ap2, pi);

								System.err.println("pi, 1: " + pi);
								
								if(!pi.equals(tp1) && !pi.equals(tp2))
									twoWayIntersectReplace(tp1, tp2, pi);
								
								System.err.println("pi, 2: " + pi);

							}
							else
							{
								// add the new point to the main points Vector
								pathPoints.add(pi);
								twoWayIntersectReplace(ap1, ap2, pi);
								twoWayIntersectReplace(tp1, tp2, pi);
							}


							
							
							System.err.println("pi, after: " + pi);
							
							System.err.println("ap1, after: " + ap1);
							System.err.println("ap2, after: " + ap2);
							System.err.println("tp1, after: " + tp1);
							System.err.println("tp2, after: " + tp2);
							
							// since we've found an intercept, abort this
							// entire test line, and move on to the next 
							// 'active point 2'
							continue AP1;
						}
						
					}
		    	}

			}
    	}
        
        System.err.println("End intersections().");
    }
    
    public int checkForPathPointOverlap(PathPoint pi)
    {
		// Loop through all path points again to look for intersections
		for(int overlapIndex = 0; overlapIndex < pathPoints.size();
			overlapIndex++)
		{
			// If the active PathPoint intersects with a PathPoint, 
			// then that PathPoint is an overlap PathPoint
			if(pi.point.equals(
					getPointAtPathPointsIndex(overlapIndex)))
			{
				System.err.println("Identical PathPoint found for intersections");
				return(overlapIndex);
			}
		}
		return(-1);
    }

    public boolean checkRange(double val1, double val2, double testVal)
    {
    	System.err.println("CHECKRANGE:");
    	double min = Math.min(val1, val2);
    	double max = Math.max(val1, val2);
    	System.err.println("Min: " + min + " Max: " + max + "test: " + testVal);
    	if(testVal < min)
    		return(false);
    	if(testVal > max)
    		return(false);
    	return(true);
    }
    /**
     * Test if a given point is in the rectangle defined by two lines.
     * (If it is, it's _possible_ that the line is the intersect point of
     * the two lines. This function is used as one of the screening tests for
     * that.)
     * @param ap1 first point in first test line
     * @param ap2 second point in first test line
     * @param tp1 first point in the second test line
     * @param tp2 second point in the second test line
     * @param pi the point to test
     * @return true if pi is in the common area of the rectangles defined by 
     * the lines ap1-ap2 and tp1-tp2, false otherwise.
     */    
    public boolean pointInSegments(PathPoint ap1, PathPoint ap2, PathPoint tp1,
    		PathPoint tp2, PathPoint pi)
    {
    	Rectangle rec1 = createRectangle(ap1.point,ap2.point);
    	// if the point isn't in the first rectangle, it can't be in both
    	if(!rec1.contains(pi.point))
    		return(false);
    	
    	Rectangle rec2 = createRectangle(tp1.point, tp2.point);
    	// if the point isn't in the second rectangle, it can't be in both
    	if(!rec2.contains(pi.point))
    		return(false);
    	
    	// by this point, we've tested both rectangles
    	return(true);
    }
    
    /**
     * Test if the rectangles defined by the line segments ap1-ap2 and
     * tp1-tp2 intersect. If they don't, the two lines cannot possibly
     * intersect (but just because the rectangles intersect doesn't mean
     * the lines do).
     * @param ap1 first point in first test line
     * @param ap2 second point in first test line
     * @param tp1 first point in the second test line
     * @param tp2 second point in the second test line
     * @return
     */
    public boolean rectangleTest(PathPoint ap1, PathPoint ap2, PathPoint tp1,
    		PathPoint tp2)
    {
    	Rectangle rec1 = createRectangle(ap1.point,ap2.point);
    	Rectangle rec2 = createRectangle(tp1.point, tp2.point);
    	return(rec1.intersects(rec2));
    }
    
    /**
     * Create a Rectangle object defined by the two given points. Order
     * does not matter.
     * @param p1 A point defining one corner of the Rectangle
     * @param p2 A point defining the other corner of the Rectangle
     * @return A rectangle with corners at the given points.
     */
    public Rectangle createRectangle(Point p1, Point p2)
    {
    	int x = Math.min(p1.x, p2.x);
    	int y = Math.min(p1.y, p2.y);
    	int height = Math.abs(p2.y - p1.y);
    	int width = Math.abs(p2.x - p1.x);
    	return(new Rectangle( x, y, width + 1, height + 1));
    }

    /**
     * Call intersectReplace on both combinations of p1 and p2, to effect a 
     * full integration of pi into the line segment connecting p1 and p2.
     * 
     * @see intersectReplace
     * 
     * @param p1 One end of a line segment
     * @param p2 The other end of a line segment
     * @param pi A point on the line between p1 and p2
     */
    public void twoWayIntersectReplace(PathPoint p1, PathPoint p2,
            PathPoint pi)
    {
        intersectReplace(p1, p2, pi);
        intersectReplace(p2, p1, pi);
    }
    
    /**
     * Integrate one point (pi) into the line segment between two other points
     * (p1 and p2). This only connects the paths going between pi and p1. To
     * full integrate a node, this function must be called twice, swapping p1
     * and p2 on the second call.
     * 
     * @see twoWayIntersectReplace
     *
     * @param p1 One end of a line segment
     * @param p2 The other end of a line segment
     * @param pi A point on the line between p1 and p2
     */
    private void intersectReplace(PathPoint p1, PathPoint p2, PathPoint pi)
    {
    	//remove p2 from p1
    	p1.removeConnectedPoint(p2);
    	//add pi to p1
    	p1.addConnectedPoint(pi);
    	//add p1 to pi
    	pi.addConnectedPoint(p1);
    }
    
    /**
     * Get the slope between two points.
     * @param p1 The first point
     * @param p2 The second point
     * @return the slope between p1 and p2, as a double
     */
    public static double getSlope(PathPoint p1, PathPoint p2)
    {
    	if(p2.point.x == p1.point.x)
    	{
    		//throw new RuntimeException("Non real slope");
    	}
    	return(((double)(p2.point.y - p1.point.y))/
    			((double)(p2.point.x - p1.point.x)));
    }

    
    
    /**
     * Return the Point contained in the PathPoint at the given index in
     * the pathPoints vector.
     * @param index the index to check
     * @return the Point in the PathPoint at the index
     */
    public Point getPointAtPathPointsIndex(int index)
    {
    	return( ( (PathPoint)pathPoints.get( index ) ).point );
    }
    
    /**
     * Return the PathPoint at the given index in the pathPoints vector.
     * @param index the index to check
     * @return the PathPoint at the index
     */
    public PathPoint getPathPoint(int index)
    {
    	return((PathPoint)pathPoints.get( index ) );
    }
    
    
    
    
    public void convertPathPointsToGraphPoints()
    {
    	GraphPoint gp;
    	PathPoint curPP;
    	PathPoint graphPP;
    	Edge tempEdge;
    	int ppIndex;
    	int conIndex;
    	PathPoint prevPP, whereFrom;
    	
    	// the index, if any, of the Edge pointing from an endpoint to the 
    	// original point
    	int edgeIndex;
    	
    	graphPoints = new Vector();
    	
    	// create a GraphPoint for every "significant" PathPoint
    	for(ppIndex = 0; ppIndex < pathPoints.size(); ppIndex++)
    	{
    		if(getPathPoint(ppIndex).isGraphPoint())
    		{
    			// the constructor does the linking between the PathPoint
    			// and the new GraphPoint
    			gp = new GraphPoint(getPathPoint(ppIndex));
    			graphPoints.add(gp);
    			//System.err.println("Making " + gp.locLabel.name + " a GraphPoint.");
    		}
    	}
    	
    	// for all pathPoints
    	for(ppIndex = 0; ppIndex < pathPoints.size(); ppIndex++)
    	{
    		// For all significant PathPoints
    		if(!getPathPoint(ppIndex).isGraphPoint())
    			continue;
    		
    		// This gets a significant PathPoint
    		graphPP = getPathPoint(ppIndex);
    		
    		System.err.println("Signficant PathPoint " + graphPP.toString());
    		
    		// For all connections of significant PathPoints
    		for(conIndex = 0; conIndex < graphPP.numConnectedPoints();
    			conIndex++)
    		{
    			// Create new edge
				tempEdge = new Edge();
				
				// add Significant PathPoint to edge's path.
				tempEdge.path.add(graphPP.point);
				
				// Assign the endpointer
				tempEdge.endpt1 = graphPP.getGraphPoint();

				// Set the current pathPoint to be  a connection of
				// the significant pathPoint.  
    			curPP = graphPP.getConnectedPathPoint(conIndex);
    			
    			// add the connection of the significant pathPoint (a PathPoint)
    			// to the path Vector.  
    			tempEdge.path.add(curPP.point);
    			System.err.println("Adding point: " + curPP);

    			// Increment weight
    			tempEdge.weight += graphPP.getWeight(curPP);
    			
    			// Temporary holder for previous point
				whereFrom = graphPP;
				
				// Make what is the current point also the previous point
				prevPP = curPP;
				
				// Loop while we can do a pointTraversal.  
				while( (curPP = curPP.pathPointTraversal(whereFrom)) != null )
				{
					tempEdge.path.add(curPP.point);
	    			System.err.println("Adding point: " + curPP);
	    			
					tempEdge.weight += prevPP.getWeight(curPP);
					
					whereFrom = prevPP;
					prevPP = curPP;
				}
				
				//System.err.println("Setting end");
				tempEdge.endpt2 = prevPP.getGraphPoint();
				
				// check if the end point of the Edge we just created already
				// has an Edge pointing back to the original GraphPoint.
				edgeIndex = (prevPP.getGraphPoint()).outgoingEdge(
						graphPP.getGraphPoint(), tempEdge);
				System.err.println("Edge Index = " + edgeIndex);
				if(edgeIndex != -1)
				{
					// if it does, we just attach to the existing edge, and
					// discard the one we created
					graphPP.getGraphPoint().edges.add(
							prevPP.getGraphPoint().getEdge(edgeIndex));
					
					// this decrements the Edge class' static ID count
					tempEdge.discard();
					System.err.println("  --Discarding edge--");
				}
				else{
					System.err.println("  --Added edge--");
					System.err.println("tempEdge's ID:" + tempEdge.ID);
					System.err.println(" To graph: " + graphPP.getGraphPoint().ID);
					// take significant pathPoint, get its corresponding
					// graph point.  Use that point to add the new edge created
					// to the graph point's edge vector.  
					( graphPP.getGraphPoint() ).edges.add(tempEdge);
					
					// save the edge's path we added so we can print it later
					outPaths.add(tempEdge.path);
					outEdges.add(tempEdge);
				}
				
    		}
    		
    	}
    	for(int graphPI = 0; graphPI < graphPoints.size(); graphPI++)
    	{
    		 System.err.println(((GraphPoint)graphPoints.get(graphPI)).toString());
    	}
    }
    
    
    
    
}

/**
 * A Point that contains a list of the PathPoints it is connected to, as well 
 * as an optional pointer to an associated Location.
 */
class PathPoint
{
	// Point where the PathPoint is located at
	Point point;

	// This field is a vector of Points that are
	// connected to the PathPoint's point.
	Vector connectedPoints;
	// Any location associated with the point
	Location location;
	
	private GraphPoint graphPoint = null;

	/**
	 * @return Returns the graphPoint.
	 */
	public GraphPoint getGraphPoint() {
		return graphPoint;
	}
	/**
	 * @param graphPoint The graphPoint to set.
	 */
	public void setGraphPoint(GraphPoint graphPoint) {
		this.graphPoint = graphPoint;
	}
	
	/**
	 * Tests to see if two points have the same location.
	 * @param p
	 * @return
	 */
	public boolean equals(PathPoint p)
	{
		return( ( p.point ).equals( point ) );
	}
	
	
	/**
	 * Simple constructor for making path points.
	 * Simply initilize the 3 main fields of pathPoints.  graphPoint is
	 * initilized to null since we don't even know about graphPoints yet.
	 * (If you're following through the program, don't think about 
	 * graphPoints yet). 
	 * @param inpoint What to initilize the Point field point to.  
	 * @param inConnectPoints What to initilize the Vector field 
	 * connetedPoints to.  This field is a vector of Points that are
	 * connected to the PathPoint's point.
	 * @param inLoc The location to initilize the PathPoint to
	 * The location is the location associated with PathPoint's point.
	 */
	public PathPoint(Point inPoint, Vector inConnectPoints, Location inLoc){
		// Simply initilize the fields to the ones passed in.  
		point = inPoint;
		connectedPoints = inConnectPoints;
		location =  inLoc;
	}
	
	/**
	 * Add the given point to this point's connectedPoints vector.
	 * @param p Point to add
	 */
	public void addConnectedPoint(PathPoint p)
	{
		if(p != null)
			connectedPoints.add(p);
	}
	
	/**
	 * Remove the given point from this point's connectedPoints vector.
	 * @param p Point to remove
	 * @return true if the point was was found and could be removed, false
	 * otherwise.
	 */
	public boolean removeConnectedPoint(PathPoint p)
	{
		return connectedPoints.remove(p);
	}
	
	/**
	 * Get the number of connected points
	 * @return number of connected points
	 */
	public int numConnectedPoints(){
		return(connectedPoints.size());
	}
	/**
	 * Get the point at given index in Vector of connected points
	 * @param index Index to get point from
	 * @return point at given index
	 */
	public Point getConnectedPoint(int index){
		return((Point)getConnectedPathPoint(index).point);
	}
	
	/**
	 * Get the PathPoint at given index in Vector of connected points.
	 * @param index Index to get PathPoint from
	 * @return point at given index
	 */
	public PathPoint getConnectedPathPoint(int index){
		return((PathPoint)connectedPoints.get(index));
	}

	/**
	 * Checks to see if a line (represented by the calling PathPoint
	 * and the passed in PathPoint) represents a PathPoint we don't want
	 * to have a intersection on.  
	 * Returns true only if both use the tag '&lt;nolink&gt;'
	 * 
	 * @param other The PathPoint to use to simulate the line.
	 * @return True if no intersection should be drawn.  False otherwise.
	 */
	public boolean allowLink(PathPoint other)
	{
        // PathPoints that don't have locations can't suppress linking
        // (this also guards against null-pointer exceptions below)
        if(location == null || other.location == null)
            return true;
        
        return (location.isAllowIntersections()
                &&  other.location.isAllowIntersections()
                );

	}
	
	/**
	 * Checks to see if the point is a GraphPoint (also talked about as a
	 * significant point).  
	 * So, if the graphPoint has no connected points, it won't become
	 * a graphPoint.  Since by definition it's not connected to a graphPoint,
	 * and we're creating the graph based on GraphPoints, the non-connected
	 * point will disappear from the graph!
	 * @return True if the point has more than 2 connected points or
	 * if it has only one connected point. Also returns true if the point
	 * has a location label.   
	 */
	public boolean isGraphPoint()
	{
		if(numConnectedPoints() > 2 || numConnectedPoints() == 1)
			return(true);
		// Null guard to prevent exceptions
		if(location != null && !location.name.equals("<nolink>"))
			return(true);
		return(false);
	}
	
	/**
	 * This method is used by convertPathPointsToGraphPoints.  
	 * It is used to let us traverse through PathPoints until a GraphPoint 
	 * is found.  The function will return null is the point is a GraphPoint.
	 * This also checks to ensure that the this PathPoint only has two
	 * connections.  We then return the connection to the thisPoint that
	 * is not the previous PathPoint.  
	 * 
	 * @param prevPoint The point that we were previously at in the traversal.
	 * @return The next pathPoint in the traversal.  
	 */
	public PathPoint pathPointTraversal(PathPoint prevPoint)
	{
		if(isGraphPoint())
			return(null);
		
		if(prevPoint == getConnectedPathPoint(0))
			return(getConnectedPathPoint(1));
		return(getConnectedPathPoint(0));
	}
	
	/**
	 * 
	 * @param p
	 * @return
	 */
	public double getWeight(PathPoint p)
	{
		return(point.distance(p.point));
	}
	
	/**
	 * Print this PathPoint's x/y coordinates, the name of its associated
	 * Location (if applicable), and the coordinates of any connections it has.
	 */
	public String toString(){
		String outStr = "(" + point.x + ", " + point.y + ") ";
		if(location != null)
			outStr += " [" + location.name + "]";
		for(int i = 0; i < numConnectedPoints(); i++){
			outStr += "\n\t --> (" + getConnectedPoint(i).x + ", " +
				getConnectedPoint(i).y + ")";
		}
		outStr += "\n";
		
		return outStr;
	}
}


class GraphPoint
{
	// Binary file identifier
	int ID;
	Point point;
	Vector edges;
	Location locLabel;
	
	// Binary file identifier
	static int IDcount = 1;
	
	public GraphPoint(PathPoint pp)
	{
		point = new Point(pp.point);
		pp.setGraphPoint(this);
	
		if(pp.location != null && !pp.location.name.equals("<nolink>"))			
			locLabel = pp.location;

		edges = new Vector();
		// Set the ID and increment the static variable for the next ID
		ID = IDcount++;
	}
	
	/**
	 * Returns an edge at the specified index of the GraphPoint.  
	 * Basically avoids the ugly casing.  
	 * @param index The specified index
	 * @return The Edge at the the specified index.  
	 */
	public Edge getEdge(int index)
	{
		return( (Edge)edges.get( index ) );
	}
	
	/**
	 * This checks if the current GraphPoint has any OUTGOING Edges
	 * that point to the passed-in point. It does NOT check incoming Edges
	 * (that is, Edges that were set from other GraphPoints).
	 * @param gp The passed-in point
	 * @return true if current point has Edges that point to 'gp', false
	 * otherwise
	 */
	public int outgoingEdge(GraphPoint gp, Edge incoming)
	{
		// an edge that may match the incoming edge
		// (one of the calling GraphPoint's edges)
		Edge outEdge;
		boolean forward = true;
		boolean reverse = true;
		for(int i = 0; i < edges.size(); i++)
		{
			// Reset the boolean values
			forward = true;
			reverse = true;
			System.err.println("If condition: " + getEdge(i).endpt2.point +
					" == " + gp.point);
			if(getEdge(i).endpt2 == gp){
				outEdge = (Edge)getEdge(i);
			
				System.err.println("Size condition: " + outEdge.path.size()
						+ " == " + incoming.path.size());
				if( outEdge.path.size() != incoming.path.size() )
					continue;
				
				// we know the sizes are the same now, so we don't have to
				// worry about overruning indices
				// Go through reverse order
				for(int ptIndex = 0; ptIndex < outEdge.path.size();
					ptIndex++)
				{
					System.err.println("Comparing: " + 
							outEdge.path.get(outEdge.path.size() - ptIndex -1 ) 
							+ " and "
							+ incoming.path.get(ptIndex));
					if(!outEdge.path.get(
							outEdge.path.size() - ptIndex -1 ).equals(
							incoming.path.get(ptIndex)))
						reverse = false;

				}

				// Go through forward order
				for(int ptIndex = 0; ptIndex < outEdge.path.size();
					ptIndex++)
				{
					if(!outEdge.path.get(ptIndex).equals(
							incoming.path.get(ptIndex)))
						forward = false;

				}
				// If one of the ways that you compared
				// the two edges turned to be true
				// Then you want to discard.  So return the index
				if(forward || reverse)
					return(i);
			}
		}
		// If no edges were  found to be equal to the passed in edge
		// Then we did not find a match, so we do not want to discard
		// In other words, we want to add
		return(-1);
	}
	
	/**
	 * Write a serialized representation of this GraphPoint to disk, using
	 * only primitive data types, so that it can be reconstructed by
	 * other applications in other languages.
	 * @param out Output stream
	 */
	public void binaryWrite(DataOutputStream out)
	{
		final int WEIGHT_SCALE = 100;  // scaling of the weight.  
    	// output ID of GraphPoint
		try{
			System.err.println("ID: " + ID + "      (" + point.x + ", "
					+ point.y + ")");
			out.writeInt(ID);
	    	// output number of connections/weights/edges
			System.err.println("Connections/weights/edges: " + edges.size());
			out.writeInt(edges.size());
			
			// for each Edge connected to this GraphPoint
			for(int i = 0; i < edges.size(); i++)
			{
	    		System.err.println("--Start connection--");
	    		// print ID of each connection
				if(((Edge)edges.get(i)).endpt1 == this){
					System.err.println("Connection ID (endpt2): " +
							((Edge)edges.get(i)).endpt2.ID);
					out.writeInt( ((Edge)edges.get(i)).endpt2.ID );
				}
				else{
					System.err.println("Connection ID (endpt1): " +
							((Edge)edges.get(i)).endpt1.ID);
					out.writeInt( ((Edge)edges.get(i)).endpt1.ID );
				}
				
				// print value of each weight
	    		out.writeInt( 
	    				(int)((WEIGHT_SCALE)*((Edge)edges.get(i)).weight) );
	    		System.err.println("Weight: " + 
	    				(int)((WEIGHT_SCALE)*((Edge)edges.get(i)).weight));
				
	    		// print ID of each edge
	    		out.writeInt( ((Edge)edges.get(i)).ID );
	    		System.err.println("Edge ID: " + ((Edge)edges.get(i)).ID);
	    		
			}
    		
			// write the ID of the associated location, if there is one;
			// if there isn't, use 0 (all IDs are > 0)
			if(locLabel != null){
				System.err.println("Location ID: " + locLabel.ID);
				out.writeInt(locLabel.ID);
			}
			else
			{
				System.err.println("Location ID: 0");
				out.writeInt(0);		
			}
			
			System.err.println("---end---");
		}
		catch(IOException e)
		{
			System.err.println("Error in GraphPoint.binaryWrite!");
		}
	}
	
	/**
	 * Write data about this GraphPoint's associated Location,
	 * if it has one. If this.locLabel == null, then nothing is
	 * written to the output stream.
	 * @param out Output stream
	 */
	public void binaryWriteLocation(DataOutputStream out)
	{
		// don't do anything if we don't have a label
		if(locLabel == null)
			return;
	
		try{
			// output ID of Location
			System.err.println("Location ID: " + locLabel.ID);
			out.writeInt(locLabel.ID);
	        // output (x,y) coordinates of Location
			System.err.println("Location coords: (" + locLabel.cord.x +
					", " + locLabel.cord.y + ")");
			out.writeInt(locLabel.cord.x);
			out.writeInt(locLabel.cord.y);
	        // output ID of associated GraphPoint
			System.err.println("Associated GraphPoint: " + ID);
			out.writeInt(ID);
	        // output length of display name
			System.err.println("Display name length: "
					+ locLabel.name.length());
			out.writeInt(locLabel.name.length());
			// output display name
			System.err.println("Display name: " + locLabel.name);
			out.writeChars(locLabel.name);
			
			System.err.println("---end---");
		}
	    catch(IOException e){
	    	System.err.println("Error in GraphPoint.binaryWriteLocation!");
	    }
	    
	}

	/**
	 * Checks to see if the location label is null, if it isn't null
	 * returns the location label's name field with a newline.  
	 * @return location name if non-null, else null-string.  
	 */
	public String getLocationName()
	{
		if(locLabel != null)
			return(locLabel.name + "\n");
		return("");
	}
	
	
	public String toString()
	{
		String outStr = "GraphPoint @ (" + point.x + ", " + point.y + ")\n";
		outStr += getLocationName();
		for(int i = 0; i < edges.size(); i++)
			outStr +=  ((Edge)edges.get(i)).toString();
		return(outStr);
	}
}

class Edge
{
	// Binary file identifier
	int ID;
	
	// The endpoints of the edge.  
	// Both of these graphs contain a pointer to this Edge.
	// (But there is only one copy of the edge)
	GraphPoint endpt1;
	GraphPoint endpt2;
	
	Vector path;  // Vector Points
	double weight = 0;
	
	// Binary file identifier
	static int IDcount = 1;
	
	public Edge()
	{
		path = new Vector();
		endpt1 = endpt2 = null;
		
		// Set the ID and increment the static variable for the next ID
		ID = IDcount++;
	}
	
	/**
	 * If we discard an edge, the decrement the ID count.
	 * This occurs because we created an edge, but did not add the edge
	 * to any graphPoints.  So, the Edge is thrown away and we want to throw
	 * away it's ID number.  
	 */
	public void discard(){
		IDcount--;
	}
	
	/**
	 * toString method for Edges.  
	 * This method is used for debugging.  
	 */
	public String toString()
	{
		String outStr = "End Point 1: " + endpt1.point + "\nEnd Point 2: " +
		endpt2.point + "\n";
		
		for(int i = 0; i < path.size(); i++)
		{
			outStr += "   -->" + this.getPointInPath(i).toString() + "\n";
		}
		outStr += "Total weight: " + weight + "\n";
		
		return(outStr);
	}
	
	/**
	 * This method gets a Point in the path element of edge.  
	 * @param i The index in the path to get the element from.  
	 * @return Point in the Path element of 
	 */
	public Point getPointInPath(int i)
	{
		return((Point)path.get(i));
	}
	
	/**
	 * Get's the weight (the simple distance sum) of the edge.
	 * @return weight (a double).
	 */
	public double getWeight()
	{
		return(weight);
	}
	
	/**
	 * Write a serialized representation of this Edge to disk, using
	 * only primitive data types, so that it can be reconstructed by
	 * other applications in other languages.
	 * @param out Output stream
	 */
	public void binaryWrite(DataOutputStream out)
	{
		try{
			//print ID of edge
			System.err.println("Edge ID: " + ID);
			out.writeInt(ID);

	    	// print ID of starting GraphPoint
			System.err.println("Start GraphPoint ID: " + endpt1.ID);
			out.writeInt(endpt1.ID);
			
	    	// print ID of ending GraphPoint
			System.err.println("End GraphPoint ID: " + endpt2.ID);
			out.writeInt(endpt2.ID);
			
	    	// print number of points
			System.err.println("Number of points: " + path.size());
			out.writeInt(path.size());

			// print ordered pairs
			for(int i = 0; i < path.size(); i++)
			{
				System.err.println("Coordinate: (" + ((Point)path.get(i)).x
						+ ", " + ((Point)path.get(i)).y + ")");
				out.writeInt(((Point)path.get(i)).x);
				out.writeInt(((Point)path.get(i)).y);
			}
			
			System.err.println("---end---");
		}
		catch(IOException e)
		{
			System.err.println("Error in Edge.binaryWrite!");
		}
	}
}